/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1()):                                   FactorySpecGithubConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1()):                                              FactorySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1()):                                     FactorySpecVstsConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1()):               FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1()):          FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1()):                FactoryDatasetDelimitedTextSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1()):                   FactoryDatasetJSONSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1()):                         FactoryDatasetJSONSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1()):                FactoryDatasetParquetSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1()):                      FactoryDatasetParquetSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1()):                FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1()):          FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1()):            FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1()):                  FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1()):            FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1()):              FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1()):                 FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1()):              FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1()):          FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1()):          FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1()):         FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1()): FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1()):         FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1()):                 FactoryLinkedServiceOdataSpecBasicAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1()):                FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1()):        FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1()):                FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1()):                  FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1()):        ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1()):                                ProtectionBackupVaultSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1()):                                        ShareSpecSnapshotScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1()):                                         ShareAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1()):                        ShareDatasetBlobStorageSpecStorageAccountCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1()):                                   FactorySpecGithubConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1()):                                              FactorySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1()):                                     FactorySpecVstsConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1()):               FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1()):          FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1()):                FactoryDatasetDelimitedTextSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1()):                   FactoryDatasetJSONSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1()):                         FactoryDatasetJSONSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1()):                FactoryDatasetParquetSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1()):                      FactoryDatasetParquetSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1()):                FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1()):          FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1()):            FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1()):                  FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1()):            FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1()):              FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1()):                 FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1()):              FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1()):          FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1()):          FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1()):         FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1()): FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1()):         FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1()):                 FactoryLinkedServiceOdataSpecBasicAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1()):                FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1()):        FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1()):                FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1()):                  FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1()):        ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1()):                                ProtectionBackupVaultSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1()):                                        ShareSpecSnapshotScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1()):                                         ShareAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1()):                        ShareDatasetBlobStorageSpecStorageAccountCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type FactorySpecGithubConfigurationCodec struct {
}

func (FactorySpecGithubConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecGithubConfiguration)(ptr) == nil
}

func (FactorySpecGithubConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecGithubConfiguration)(ptr)
	var objs []FactorySpecGithubConfiguration
	if obj != nil {
		objs = []FactorySpecGithubConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecGithubConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecGithubConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecGithubConfiguration)(ptr) = objs[0]
			} else {
				*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
			}
		} else {
			*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactorySpecGithubConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactorySpecGithubConfiguration)(ptr) = obj
		} else {
			*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		}
	default:
		iter.ReportError("decode FactorySpecGithubConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactorySpecIdentityCodec struct {
}

func (FactorySpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecIdentity)(ptr) == nil
}

func (FactorySpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecIdentity)(ptr)
	var objs []FactorySpecIdentity
	if obj != nil {
		objs = []FactorySpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecIdentity)(ptr) = objs[0]
			} else {
				*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
			}
		} else {
			*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactorySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactorySpecIdentity)(ptr) = obj
		} else {
			*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		}
	default:
		iter.ReportError("decode FactorySpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactorySpecVstsConfigurationCodec struct {
}

func (FactorySpecVstsConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecVstsConfiguration)(ptr) == nil
}

func (FactorySpecVstsConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecVstsConfiguration)(ptr)
	var objs []FactorySpecVstsConfiguration
	if obj != nil {
		objs = []FactorySpecVstsConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecVstsConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecVstsConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecVstsConfiguration)(ptr) = objs[0]
			} else {
				*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
			}
		} else {
			*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactorySpecVstsConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactorySpecVstsConfiguration)(ptr) = obj
		} else {
			*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		}
	default:
		iter.ReportError("decode FactorySpecVstsConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecAzureBlobFsLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecAzureBlobFsLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetDelimitedTextSpecAzureBlobFsLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecAzureBlobFsLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetDelimitedTextSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetJSONSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetJSONSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetJSONSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetJSONSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetJSONSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetJSONSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetJSONSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetJSONSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetJSONSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetJSONSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetJSONSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetJSONSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetJSONSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetJSONSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetParquetSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetParquetSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetParquetSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetParquetSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetParquetSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetParquetSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetParquetSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetParquetSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetParquetSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetParquetSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetParquetSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetParquetSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetParquetSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetParquetSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecCatalogInfo
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecCatalogInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeManagedSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecCatalogInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecCustomSetupScript
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecCustomSetupScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeManagedSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecCustomSetupScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecVnetIntegration
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecVnetIntegration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeManagedSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecVnetIntegration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec struct {
}

func (FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) == nil
}

func (FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr)
	var objs []FactoryLinkedCustomServiceSpecIntegrationRuntime
	if obj != nil {
		objs = []FactoryLinkedCustomServiceSpecIntegrationRuntime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedCustomServiceSpecIntegrationRuntime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
			}
		} else {
			*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedCustomServiceSpecIntegrationRuntime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = obj
		} else {
			*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
		}
	default:
		iter.ReportError("decode FactoryLinkedCustomServiceSpecIntegrationRuntime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecInstancePool
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecInstancePool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecInstancePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureDatabricksSpecInstancePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecInstancePool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec struct {
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) == nil
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr)
	var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString
	if obj != nil {
		objs = []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
			}
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceOdataSpecBasicAuthenticationCodec struct {
}

func (FactoryLinkedServiceOdataSpecBasicAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) == nil
}

func (FactoryLinkedServiceOdataSpecBasicAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr)
	var objs []FactoryLinkedServiceOdataSpecBasicAuthentication
	if obj != nil {
		objs = []FactoryLinkedServiceOdataSpecBasicAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceOdataSpecBasicAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceOdataSpecBasicAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
			}
		} else {
			*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceOdataSpecBasicAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceOdataSpecBasicAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSnowflakeSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSnowflakeSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec struct {
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) == nil
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr)
	var objs []FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString
	if obj != nil {
		objs = []FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
			}
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSQLServerSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSQLServerSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSQLServerSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSQLServerSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSQLServerSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSynapseSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSynapseSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSynapseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSynapseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSynapseSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec struct {
}

func (ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) == nil
}

func (ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr)
	var objs []ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria
	if obj != nil {
		objs = []ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = objs[0]
			} else {
				*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
			}
		} else {
			*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = obj
		} else {
			*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
		}
	default:
		iter.ReportError("decode ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProtectionBackupVaultSpecIdentityCodec struct {
}

func (ProtectionBackupVaultSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProtectionBackupVaultSpecIdentity)(ptr) == nil
}

func (ProtectionBackupVaultSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProtectionBackupVaultSpecIdentity)(ptr)
	var objs []ProtectionBackupVaultSpecIdentity
	if obj != nil {
		objs = []ProtectionBackupVaultSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProtectionBackupVaultSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProtectionBackupVaultSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProtectionBackupVaultSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
			}
		} else {
			*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProtectionBackupVaultSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProtectionBackupVaultSpecIdentity)(ptr) = obj
		} else {
			*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
		}
	default:
		iter.ReportError("decode ProtectionBackupVaultSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareSpecSnapshotScheduleCodec struct {
}

func (ShareSpecSnapshotScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareSpecSnapshotSchedule)(ptr) == nil
}

func (ShareSpecSnapshotScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareSpecSnapshotSchedule)(ptr)
	var objs []ShareSpecSnapshotSchedule
	if obj != nil {
		objs = []ShareSpecSnapshotSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareSpecSnapshotScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareSpecSnapshotSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareSpecSnapshotSchedule)(ptr) = objs[0]
			} else {
				*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
			}
		} else {
			*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ShareSpecSnapshotSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ShareSpecSnapshotSchedule)(ptr) = obj
		} else {
			*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		}
	default:
		iter.ReportError("decode ShareSpecSnapshotSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareAccountSpecIdentityCodec struct {
}

func (ShareAccountSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareAccountSpecIdentity)(ptr) == nil
}

func (ShareAccountSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareAccountSpecIdentity)(ptr)
	var objs []ShareAccountSpecIdentity
	if obj != nil {
		objs = []ShareAccountSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareAccountSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareAccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareAccountSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
			}
		} else {
			*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ShareAccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ShareAccountSpecIdentity)(ptr) = obj
		} else {
			*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		}
	default:
		iter.ReportError("decode ShareAccountSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareDatasetBlobStorageSpecStorageAccountCodec struct {
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareDatasetBlobStorageSpecStorageAccount)(ptr) == nil
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareDatasetBlobStorageSpecStorageAccount)(ptr)
	var objs []ShareDatasetBlobStorageSpecStorageAccount
	if obj != nil {
		objs = []ShareDatasetBlobStorageSpecStorageAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareDatasetBlobStorageSpecStorageAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = objs[0]
			} else {
				*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
			}
		} else {
			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ShareDatasetBlobStorageSpecStorageAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = obj
		} else {
			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		}
	default:
		iter.ReportError("decode ShareDatasetBlobStorageSpecStorageAccount", "unexpected JSON type")
	}
}
